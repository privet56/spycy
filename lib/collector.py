import os, sys
import re
import pickle
import unidecode

class Collector:

    MAX_FILES_DEFAULT=9999999
    PICKLE_FILENAME_POSTFIX = ".collector.pickle"
    SRC_SEPARATOR = '\n\n'
    AUTOGENERATED_CODE_PREFIX = ".autoGeneratedCode."

    '''
    base class collector with basic functions
    to be extended
    '''

    # like constructor(beside __new__)
    def __init__(self, source, datadir):
        self.source = source
        self.datadir = datadir
        self.aSRCs = None
        self.sCode = None
        self.lChars = None
        self.dChars2idx = None

    ''' helper functions '''
    @staticmethod
    def replacer(value):
        if ' ' in value and sum(1 for ch in value if ch.isalpha()) > 6:
            return ' '
        return value

    @staticmethod
    def remove_non_ansi(text):
        return ''.join([word for word in text if ord(word) < 128255])

    def collect(self, source):
        pass

    def startWith(self):
        pass

    def find(self, source, postfix, max_files=MAX_FILES_DEFAULT):
        self.aSRCs = []
        for root, _, filenames in os.walk(source):
            for fn in filenames:
                if fn.endswith(postfix):
                    if(fn.find(Collector.AUTOGENERATED_CODE_PREFIX) < 1):
                        self.aSRCs.append(os.path.join(root, fn))
                        if(len(self.aSRCs) > max_files):
                            print("max srcs("+postfix+") ("+str(max_files)+") reached -> abort traversing dirs...")
                            return self.aSRCs
        return self.aSRCs


    def writeCollectedData(self, prefix):

        assert self.sCode != None
        assert self.lChars != None
        assert self.dChars2idx != None

        # save as text

        with open(os.path.join(self.datadir, prefix+".code.txt"), 'w', ) as codefile:       # 'w' overwrites
            codefile.write(self.sCode)
        with open(os.path.join(self.datadir, prefix+".chars.txt"), 'w', ) as charsfile:
            charsfile.write('\n'.join(self.lChars))                                     # alt: .write('\n'.join(str(line) for line in self.lChars))
        with open(os.path.join(self.datadir, prefix+".chars2idx.txt"), 'w', ) as chars2idxfile:
            for k, v in self.dChars2idx.items():
                chars2idxfile.write(str(k) + ' = '+ str(v) + '\n')

        # save self as binary, pickle:
        with open(os.path.join(self.datadir, prefix + Collector.PICKLE_FILENAME_POSTFIX), 'wb', ) as p:
            pickle.dump(self.__dict__, p, protocol=pickle.HIGHEST_PROTOCOL)
    
    def loadCollectedData(self, prefix):

        self.sCode = None
        self.lChars = None
        self.dChars2idx = None

        with open(os.path.join(self.datadir, prefix + Collector.PICKLE_FILENAME_POSTFIX), 'rb', ) as p:
            dict = pickle.load(p)
        self.__dict__.update(dict)

        assert self.sCode != None
        assert self.lChars != None
        assert self.dChars2idx != None

        assert len(self.sCode) > 1
        assert len(self.lChars) > 1
        assert len(self.dChars2idx) > 1

    max_len_found = -1
    max_len_allowed = 64    #128

    def truncateSentence(self, sentence):
        l = len(sentence)
        if((l > self.max_len_found) and (l > 19)):
            self.max_len_found = l
            #self.logger.log("longest sentence had "+str(self.max_len_found)+" chars")  #over 1000 chars

        if(l <= self.max_len_allowed):
            return sentence

        sentence = sentence[0:self.max_len_allowed]

        lastspace = sentence.rfind(' ')         #remove last incomplete word
        sentence = sentence[0:lastspace]
        return sentence

    allowedChars = "abcdefghijklmnopqrstuvwxyzäöüß"

    def clarifySentence(self, sentence):

        sentence = sentence.lower().strip()
        sentence = unidecode.unidecode(sentence)

        sentence = sentence.replace('"a', 'ä')
        sentence = sentence.replace('"u', 'ü')
        sentence = sentence.replace('"o', 'ö')
        sentence = sentence.replace('"s', 'ß')

        sentence = sentence.replace('??', 'ä')
        sentence = sentence.replace('ã ', 'ö')
        sentence = sentence.replace('ã¼', 'ü')
        sentence = sentence.replace('ãÿ', 'ß')

        for ch in sentence:
            if(self.allowedChars.find(ch) < 0):
                sentence = sentence.replace(ch, ' ')

        while(sentence.find('  ') > -1):
            sentence = sentence.replace('  ', ' ').strip()

        return sentence

    def questionify(self, question):
        question = self.clarifySentence(question)
        question = self.truncateSentence(question)
        return question
